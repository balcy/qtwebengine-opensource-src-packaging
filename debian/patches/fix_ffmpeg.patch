Description: Adopt API changes
 As also written in APIChanges in the thrid_party directory,
 upstream has renamed PixelFormat to AVPixelFormat. 
 System version has stript out the old interface completly.
Author: Sandro Knau√ü <bugs@sandroknauss.de>
Origin: Debian
Last-Update: 2016-08-01
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/src/3rdparty/chromium/media/cdm/ppapi/external_clear_key/ffmpeg_cdm_video_decoder.cc
+++ b/src/3rdparty/chromium/media/cdm/ppapi/external_clear_key/ffmpeg_cdm_video_decoder.cc
@@ -21,9 +21,9 @@ namespace media {
 
 static const int kDecodeThreads = 1;
 
-static cdm::VideoFormat PixelFormatToCdmVideoFormat(PixelFormat pixel_format) {
+static cdm::VideoFormat PixelFormatToCdmVideoFormat(AVPixelFormat pixel_format) {
   switch (pixel_format) {
-    case PIX_FMT_YUV420P:
+    case AV_PIX_FMT_YUV420P:
       return cdm::kYv12;
     default:
       DVLOG(1) << "Unsupported PixelFormat: " << pixel_format;
@@ -31,16 +31,16 @@ static cdm::VideoFormat PixelFormatToCdm
   return cdm::kUnknownVideoFormat;
 }
 
-static PixelFormat CdmVideoFormatToPixelFormat(cdm::VideoFormat video_format) {
+static AVPixelFormat CdmVideoFormatToPixelFormat(cdm::VideoFormat video_format) {
   switch (video_format) {
     case cdm::kYv12:
     case cdm::kI420:
-      return PIX_FMT_YUV420P;
+      return AV_PIX_FMT_YUV420P;
     case cdm::kUnknownVideoFormat:
     default:
       DVLOG(1) << "Unsupported cdm::VideoFormat: " << video_format;
   }
-  return PIX_FMT_NONE;
+  return AV_PIX_FMT_NONE;
 }
 
 static AVCodecID CdmVideoCodecToCodecID(
@@ -267,7 +267,7 @@ cdm::Status FFmpegCdmVideoDecoder::Decod
 
 bool FFmpegCdmVideoDecoder::CopyAvFrameTo(cdm::VideoFrame* cdm_video_frame) {
   DCHECK(cdm_video_frame);
-  DCHECK_EQ(av_frame_->format, PIX_FMT_YUV420P);
+  DCHECK_EQ(av_frame_->format, AV_PIX_FMT_YUV420P);
   DCHECK_EQ(av_frame_->width % 2, 0);
   DCHECK_EQ(av_frame_->height % 2, 0);
 
@@ -306,7 +306,7 @@ bool FFmpegCdmVideoDecoder::CopyAvFrameT
             uv_stride,
             cdm_video_frame->FrameBuffer()->Data() + y_size + uv_size);
 
-  PixelFormat format = static_cast<PixelFormat>(av_frame_->format);
+  AVPixelFormat format = static_cast<AVPixelFormat>(av_frame_->format);
   cdm_video_frame->SetFormat(PixelFormatToCdmVideoFormat(format));
 
   cdm::Size video_frame_size;
--- a/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.cc
+++ b/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.cc
@@ -532,20 +532,20 @@ ChannelLayout ChannelLayoutToChromeChann
   }
 }
 
-VideoFrame::Format PixelFormatToVideoFormat(PixelFormat pixel_format) {
+VideoFrame::Format PixelFormatToVideoFormat(AVPixelFormat pixel_format) {
   // The YUVJ alternatives are FFmpeg's (deprecated, but still in use) way to
   // specify a pixel format and full range color combination
   switch (pixel_format) {
-    case PIX_FMT_YUV422P:
-    case PIX_FMT_YUVJ422P:
+    case AV_PIX_FMT_YUV422P:
+    case AV_PIX_FMT_YUVJ422P:
       return VideoFrame::YV16;
-    case PIX_FMT_YUV444P:
-    case PIX_FMT_YUVJ444P:
+    case AV_PIX_FMT_YUV444P:
+    case AV_PIX_FMT_YUVJ444P:
       return VideoFrame::YV24;
-    case PIX_FMT_YUV420P:
-    case PIX_FMT_YUVJ420P:
+    case AV_PIX_FMT_YUV420P:
+    case AV_PIX_FMT_YUVJ420P:
       return VideoFrame::YV12;
-    case PIX_FMT_YUVA420P:
+    case AV_PIX_FMT_YUVA420P:
       return VideoFrame::YV12A;
     default:
       DVLOG(1) << "Unsupported PixelFormat: " << pixel_format;
@@ -553,20 +553,20 @@ VideoFrame::Format PixelFormatToVideoFor
   return VideoFrame::UNKNOWN;
 }
 
-PixelFormat VideoFormatToPixelFormat(VideoFrame::Format video_format) {
+AVPixelFormat VideoFormatToPixelFormat(VideoFrame::Format video_format) {
   switch (video_format) {
     case VideoFrame::YV16:
-      return PIX_FMT_YUV422P;
+      return AV_PIX_FMT_YUV422P;
     case VideoFrame::YV12:
-      return PIX_FMT_YUV420P;
+      return AV_PIX_FMT_YUV420P;
     case VideoFrame::YV12A:
-      return PIX_FMT_YUVA420P;
+      return AV_PIX_FMT_YUVA420P;
     case VideoFrame::YV24:
-      return PIX_FMT_YUV444P;
+      return AV_PIX_FMT_YUV444P;
     default:
       DVLOG(1) << "Unsupported VideoFrame::Format: " << video_format;
   }
-  return PIX_FMT_NONE;
+  return AV_PIX_FMT_NONE;
 }
 
 bool FFmpegUTCDateToTime(const char* date_utc, base::Time* out) {
--- a/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.h
+++ b/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.h
@@ -123,10 +123,10 @@ MEDIA_EXPORT SampleFormat
 
 // Converts FFmpeg's pixel formats to its corresponding supported video format.
 MEDIA_EXPORT VideoFrame::Format PixelFormatToVideoFormat(
-    PixelFormat pixel_format);
+    AVPixelFormat pixel_format);
 
 // Converts video formats to its corresponding FFmpeg's pixel formats.
-PixelFormat VideoFormatToPixelFormat(VideoFrame::Format video_format);
+AVPixelFormat VideoFormatToPixelFormat(VideoFrame::Format video_format);
 
 // Convert FFmpeg UTC representation (YYYY-MM-DD HH:MM:SS) to base::Time.
 // Returns true and sets |*out| if |date_utc| contains a valid
--- a/src/3rdparty/chromium/media/filters/ffmpeg_demuxer.cc
+++ b/src/3rdparty/chromium/media/filters/ffmpeg_demuxer.cc
@@ -691,7 +691,7 @@ void FFmpegDemuxer::Initialize(DemuxerHo
   // this does not increase the amount of data downloaded.  The default value
   // is 5 AV_TIME_BASE units (1 second each), which prevents some oddly muxed
   // streams from being detected properly; this value was chosen arbitrarily.
-  format_context->max_analyze_duration2 = 60 * AV_TIME_BASE;
+  format_context->max_analyze_duration = 60 * AV_TIME_BASE;
 
   // Open the AVFormatContext using our glue layer.
   CHECK(blocking_thread_.Start());
